---
layout: default
title: 缓存在服务端的使用经验总结
---

在一个实际生产环境中，最简单的一个系统就三层：接入层、业务层和数据层。也就是为一些开发人员所自嘲的CRUD。  
![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/%E7%B3%BB%E7%BB%9F1.jpg "GitHub,Social Coding")  

随着系统QPS不断提升，服务层因其扩展性和机器的廉价性，很容易扩展。但是mysql却不然，随着QPS增长，负载越来越高，将会成为系统性能的瓶颈。这是缓存便会登上前台。横亘在服务端和数据库之间，保护数据库免遭崩溃，提升服务性能。  
![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6.jpg "GitHub,Social Coding")  

关于缓存的使用，天然带来了一致性的问题。当有数据更新的时候，对缓存的操作有两种：更新和删除。什么时候应该更新，什么时候应该删除，关于这个问题，网上的主流答案是：当系统的特点是写多读少，如果一个系统写了两次，只读取一次，如果采取更新的方式，那么第一次更新是无意义的，属于性能上的浪费。如下图所示：（摘自[https://wemp.app/posts/9f0f08f9-fd0a-49de-8047-9c674d5c336a](https://wemp.app/posts/9f0f08f9-fd0a-49de-8047-9c674d5c336a)）  
![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/FB91DBB4-C60F-4035-B619-7D995A17258F.png "GitHub,Social Coding")  

首先我认为这个解释的出发点就不对， 如果你的系统数据库压力是因为写的请求过多造成的，应该使用队列而不是通过使用添加缓存，更别提更新还是删除的优缺点了。  另外，更新缓存是有优势的，因为你的数据一致在redis中，不存在过期清除或者被删除的可能性，因此缓存击穿的机会大大减小，甚至出现长尾现象的概率也会降低。但是这样也是有相应代价的，那就是维护数据一致性的难度要相比起删除要大一些。在介绍这两种方式的一致性之前，首先声明一下，无论是什么决绝方案都不能做到想数据库一样的强一致性，而只能是最终一致性。因为这本质上是个多源数据的一致性问题，即便业界也没有终极方案。  

首先来分析下如果是更新缓存的话，其实讨论是先更新缓存还是先更新数据库意义不大，两种方式造成的一致性损害是等价的。稍微不通过的是，现在有很多成熟数据库监控组件如databus等，可以对数据库进行监控，便于一些特殊操作。如下图所示就是更新缓存所带来的一致性问题：
![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/E5B1EF4F-46FA-4BAB-8818-594F2934AE8C.png "GitHub,Social Coding")  

其次如果我们选择删除缓存，此时又存在两种情况：1、先删除缓存，在更新数据库；2、先更新数据库，再删除缓存。在两个操作都成功的前提下，第一个方案存在不一致性问题：比如线程A删除数据库，还没有来得及更新数据库，但是线程B从数据库中已经读取了旧的数据，此时造成数据不一致，而第二种方案则不存在这种问题。另外就是如何删除缓存，如果缓存的数据是非常热点的数据，则存在缓存穿透的问题。这时则要非常小心处理。  

如果你的系统对数据一致性要求较高，无论是删除还是更新，都可以采用如下的架构来实现，从本质上而言，就是使用MQ来实现分布式事务。如下图所示：
![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/A72C77D7-0848-4754-9766-DB5E71519A37.png "GitHub,Social Coding")   

这个的具体操作方式是：首先更新数据库，然后将更新动作以消息的形式发送给MQ，在缓存端消费消息，将缓存删除成功或者更新成功，才通知MQ消息消费成功，正式利用了MQ的持久化性和消息的持续推送能力来保证两个操作都能成功进行。  

接下来我们来讨论下当缓存失效时，对于热点数据会存在长尾响应的问题，应该如何解决。首先当然我们可以使用分布式锁来来解决，但是如果你的系统对一致性要求不高，而对性能要求比较高时（绝大多数的系统都是此种情形）。  

这种问题可以分为两种情形讨论。1、前后两次数据拉取是无状态的。针对此种情形，我们使用双缓存策略。对一个数据我们使用两个缓存1和缓存2，其中缓存1的失效时间较短，缓存2的失效时间较长。当缓存1数据过期，就回去缓存2中拉取数据，并且异步的从数据库拉取数据更新缓存1和缓存2。即便这样，还是会存在一个请求响应延时较高的点，比如缓存1的失效时间是他t1，缓存2的失效时间是t2，那么t1*t2将是响应增加的一个时间点。这个取决于你服务是否可以接受，个人认为对于缓存2设置成永久有效也是可以的。小爱开放平台就是使用的这种思路；2、如果下一次拉取数据的结果是取决于上一次的值，比如抢票、刷单以及分布式id等，此时也可以使用双buffer策略，不过拉取时机有所不同。可以对上一次数据的递减速度进行监控，当低于某一个阈值的时候，就从数据库中拉取新一次的数据作为backup。使用这种策略的关键是要做好监控打点和阈值的动态配置，尤其是对第一个已经递减完了但是第二次数据却还没有获取到来，此时可以响应的调大阈值来解决。下面的图是美团分布式id生成的策略图：  
![GitHub](http://dbp-resource.cdn.bcebos.com/a1620f93-4200-9024-4be8-61a6751b1340/7B3F2B44-BB58-4CDE-BE37-D370C5BC1E33.png "GitHub,Social Coding")  

谈完一致性问题，接下来我们分析下缓存穿透和缓存击穿问题。首先什么是缓存击穿，是指很多数据同时失效或者热点数据失效，导致本应命中缓存的请求涌向了数据库导致数据库压力；缓存穿透则是由于数据稀疏等原因导致缓存本身的命中率较低，从而请求大量去了数据库服务器。无论是哪一种方式，都会给数据库服务器造成压力进而影响服务性能，但是处理方式去不尽相同。对于缓存击穿，如果是许多数据同时失效，这个概率比较少见，一种可能的情形是服务启动时将数据加载进缓存，设置的是相同的时间。这种情况一般有效的办法是给数据失效时间加上一个可控范围内的随机量就行。如果是热点数据，导致所有请求都涌向一个缓存服务器，造成缓存服务器压力过大从而出现问题，这种情况应该采取的办法是数据冗余备份的方式，将一个key虚拟出多个key出来，比如真是的key是hash值，可以实现多种hash算法来生成多个hash值进而得的多个key值。真正取值的时候，随机使用一种hash算法即可。  

对于缓存穿透问题，我们也有两种办法。第一种是将空值存入缓存，比如NULL，但是这样浪费空间，而且还有一个潜在的问题，比如有些接口异常的时候会返回一个NULL，如果将这个值缓存下来，可能导致数据不一致性。另一种办法是在缓存和数据库之间加一个布隆过滤器。具体操作是：根据查询条件生成一个hashCode，然后将hashCode放入一个32位的byte数组上。后续每次查询数据库之前，先将hashCode值与数组进行比对，如果每个位置为1，表明数据库中可能存在对应值，如果有一个地方为0，则肯定不会有查询结果。因此这种方式有一定的误差，根据公式统计误差率在万分之几的级别，但是相比起存放空值，可以节省出出空间，但精度有所减弱，需要开发人员那结合自己的业务场景合理选择。目前一些推荐算法需要去重等操作都使用的是布隆过滤器操作。另外，布隆过滤器还是一个场景那就是大概率都是空值效果才会更显著。
